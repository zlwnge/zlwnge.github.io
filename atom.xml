<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zlwnge</title>
  
  
  <link href="https://zlwnge.top/atom.xml" rel="self"/>
  
  <link href="https://zlwnge.top/"/>
  <updated>2021-09-01T06:49:17.230Z</updated>
  <id>https://zlwnge.top/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>改进的二进制灰狼算法及其在特征选择问题上的应用</title>
    <link href="https://zlwnge.top/2021/09/01/2021-09-01-%E6%94%B9%E8%BF%9B%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%81%B0%E7%8B%BC%E7%AE%97%E6%B3%95%E5%8F%8A%E5%85%B6%E5%9C%A8%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E4%B8%8A%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>https://zlwnge.top/2021/09/01/2021-09-01-%E6%94%B9%E8%BF%9B%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%81%B0%E7%8B%BC%E7%AE%97%E6%B3%95%E5%8F%8A%E5%85%B6%E5%9C%A8%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E4%B8%8A%E7%9A%84%E5%BA%94%E7%94%A8/</id>
    <published>2021-08-31T16:00:00.000Z</published>
    <updated>2021-09-01T06:49:17.230Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Improved-Binary-Grey-Wolf-Optimizer-and-Its-application-for-feature-selection"><a href="#Improved-Binary-Grey-Wolf-Optimizer-and-Its-application-for-feature-selection" class="headerlink" title="Improved Binary Grey Wolf Optimizer and Its application for feature selection"></a>Improved Binary Grey Wolf Optimizer and Its application for feature selection</h3><p>本文基于灰狼算法提出了一个改进版本的二进制灰狼算法并将其应用于特征选择问题上</p><p>创新点：</p><ul><li>提出新的a参数更新公式以平衡全局搜索及局部搜索的能力</li><li>提出五个传递函数，提高了解的质量</li></ul><!--Read more--><h4 id="二进制灰狼算法的转换过程"><a href="#二进制灰狼算法的转换过程" class="headerlink" title="二进制灰狼算法的转换过程"></a>二进制灰狼算法的转换过程</h4><p><img src="http://image.zlwnge.top/20210901144717.png" alt="image-20210901144717853"></p><p><img src="http://image.zlwnge.top/20210901144734.png" alt="image-20210901144734799"></p><p><img src="http://image.zlwnge.top/20210901144745.png" alt="image-20210901144745859"></p><p><img src="http://image.zlwnge.top/20210901144801.png" alt="image-20210901144801705"></p><p><img src="http://image.zlwnge.top/20210901144844.png" alt="image-20210901144844584"></p><hr><h4 id="新的参数更新方程"><a href="#新的参数更新方程" class="headerlink" title="新的参数更新方程"></a>新的参数更新方程</h4><p>​        二进制灰狼算法，在算法的早期阶段，位置需要能够在0、1之间快速切换以搜索更多空间。而在后期，位置切换速度较慢，以提高搜索最优解的能力。</p><p><img src="http://image.zlwnge.top/20210901143317.png" alt="image-20210901143309050"></p><p>提出以上公式，a从0线性增加到2，在算法早期，a值较小，意味着BGWO的位置切换概率很小；随着算法不断迭代，a越来越大，BGWO切换位置的概率很大，有效的平衡了搜索与开发。</p><hr><h4 id="新的转换函数"><a href="#新的转换函数" class="headerlink" title="新的转换函数"></a>新的转换函数</h4><p>​        初始的转换函数，在函数值较大时，V1(x)、V2(x)、V3(x)、V4(x)的最大值分别是1.0000、0.9993、0.9701、0.8955。转换函数的目的是在函数值较大时有很大概率变为1，然而这些转换函数，即使x达到最大值，V2(x)、V3(x)、V4(x)也有0.07%、2.99%、10.45%的概率没有达到1。所以需要将其进行拉伸，以确保传递函数的值覆盖[0, 1]。</p><p><img src="http://image.zlwnge.top/20210901144053.png" alt="image-20210901144053769"></p><p>​        改进后的转换函数如下表。</p><p><img src="http://image.zlwnge.top/20210901144452.png" alt="image-20210901144452098"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Improved-Binary-Grey-Wolf-Optimizer-and-Its-application-for-feature-selection&quot;&gt;&lt;a href=&quot;#Improved-Binary-Grey-Wolf-Optimizer-and-Its</summary>
      
    
    
    
    <category term="论文研读" scheme="https://zlwnge.top/categories/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB/"/>
    
    
    <category term="Feature selection" scheme="https://zlwnge.top/tags/Feature-selection/"/>
    
    <category term="GWO" scheme="https://zlwnge.top/tags/GWO/"/>
    
  </entry>
  
  <entry>
    <title>特征选择的实例投票法</title>
    <link href="https://zlwnge.top/2021/08/27/2021-08-27-%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E7%9A%84%E5%AE%9E%E4%BE%8B%E6%8A%95%E7%A5%A8%E6%B3%95/"/>
    <id>https://zlwnge.top/2021/08/27/2021-08-27-%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E7%9A%84%E5%AE%9E%E4%BE%8B%E6%8A%95%E7%A5%A8%E6%B3%95/</id>
    <published>2021-08-26T16:00:00.000Z</published>
    <updated>2021-08-27T08:26:41.648Z</updated>
    
    <content type="html"><![CDATA[<h3 id="An-instance-voting-approach-to-feature-selection"><a href="#An-instance-voting-approach-to-feature-selection" class="headerlink" title="An instance voting approach to feature selection"></a>An instance voting approach to feature selection</h3><p>解决高维小样本数据集特征选择问题</p><p>创新点：</p><ul><li></li><li></li></ul><!-- Read more--><h4 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h4><p>​        高维小样本问题，主要挑战在于从少量实例中推断特征重要性和特征间的相关性。同时，小样本量也对多选特征相对于数据变化的稳定性提出了挑战。</p><p>​        常用的评估特征相关性和冗余度的方法有：信息论法、图论法</p><p>​        对于小样本情况，信息论法评估的度量可能不准确，从而导致较差的分类准确度和稳定性。</p><p>​        图论法利用数据的内在结构将单个特征或特征间的相互作用表示为图，避免了概率密度的显示估计。因此，图结构捕获了与类概念的相关性或特征间的冗余。然而，这种基于图的特征选择方法涉及大量成对的特征/图比较，对于高维数据较难处理。</p><p>​        这些方法是通过量化特征与类、特征与特征间的关系进行特征选择。但是我们从实例的角度看特征选择问题：每个实例都可以提供有价值的信息，说明一个特征对其所在区域的类标签的有用性。</p><p>​        在此基础上，提出了类似于集合覆盖问题的新的特征选择视角。目标是选择互补的特征，这些特征共同覆盖（区分）大多数实例的类别。这与组合优化中的集合覆盖问题类似，即：给定一些子集，每个子集覆盖一个或多个元素，寻求覆盖所有元素的最小数量的子集。不同的是，我们寻求特定数量的子集，使最多的元素被覆盖。</p><p>​        我们将一个实例分配给一个特征的票数定义为特征的本地相关性，即，该特征能够覆盖该实例的程度。给定一个样本，一个特征对于分类的相关性可以从样本的空间邻域信息中推断出来，如果样本周围有同一类的样本，那么这个特征就很可能对样本的分类有用。此外，这种信息可以通过将数据表示为一个图来进行编码。所以，我们将每个特征表示为一个图，其节点对应于实例，边缘权重量化为成对的接近度。由有用的特征表示的图将倾向于表现出一个社区结构。我们将每个实例对图的模块化的贡献视为该实例对相应特征的投票，并且所提出的投票方案与最小风险分类的贝叶斯决策规则渐进相关。</p><p>​        然后，利用实例投票来选择使用启发式搜索策略的特征子集。所提出的条件优先覆盖最大化（CPCM）是根据分配给每个实例的优先级来进行的；选择新的特征，使其覆盖高优先级的实例（未被已选择的特征覆盖的实例）。因此，它在选择特征的同时避免了选择多余的特征。此外，该搜索策略与n成线性关系，且对于高维数据在计算上是可行的。</p><hr><h4 id="2-提出的方法"><a href="#2-提出的方法" class="headerlink" title="2. 提出的方法"></a>2. 提出的方法</h4><p>​        </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;An-instance-voting-approach-to-feature-selection&quot;&gt;&lt;a href=&quot;#An-instance-voting-approach-to-feature-selection&quot; class=&quot;headerlink&quot; tit</summary>
      
    
    
    
    <category term="论文研读" scheme="https://zlwnge.top/categories/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB/"/>
    
    
    <category term="feature selection" scheme="https://zlwnge.top/tags/feature-selection/"/>
    
    <category term="instance voting" scheme="https://zlwnge.top/tags/instance-voting/"/>
    
    <category term="filter-based method" scheme="https://zlwnge.top/tags/filter-based-method/"/>
    
  </entry>
  
  <entry>
    <title>针对类不平衡数据的处理方法汇总</title>
    <link href="https://zlwnge.top/2021/08/11/%E4%B8%8D%E5%B9%B3%E8%A1%A1%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    <id>https://zlwnge.top/2021/08/11/%E4%B8%8D%E5%B9%B3%E8%A1%A1%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/</id>
    <published>2021-08-10T16:00:00.000Z</published>
    <updated>2021-08-11T06:53:23.989Z</updated>
    
    <content type="html"><![CDATA[<h3 id="针对类不平衡数据数据的处理方法"><a href="#针对类不平衡数据数据的处理方法" class="headerlink" title="针对类不平衡数据数据的处理方法"></a>针对类不平衡数据数据的处理方法</h3><p>类不平衡问题（class-imbalance）：指分类问题中部分类只有非常少的例子（称为少数类，minority class），而其它类有大量例子（称为多数类，majority class）的情况。（分类任务中不同类别的训练样例数目差别很大的情况）</p><p>当使用整个数据集上的总体分类精度或错误率作为性能度量时，学习模型通常会获得“较好的结果”。然而仔细检查每一个类的分类精度时，少数类的结果实际上相当糟糕，尤其是对于相对困难的问题。许多类不平衡问题中，少数类是“主要类”，正确分类这个类的例子非常重要。</p><!--Read more--><h4 id="2-欠采样"><a href="#2-欠采样" class="headerlink" title="2. 欠采样"></a>2. 欠采样</h4><p>水水水水水水水水水水</p><hr><h4 id="3-过采样"><a href="#3-过采样" class="headerlink" title="3. 过采样"></a>3. 过采样</h4><p>水水水水水水水水水水水水</p><hr><h4 id="4-使用新评价指标"><a href="#4-使用新评价指标" class="headerlink" title="4. 使用新评价指标"></a>4. 使用新评价指标</h4><p>杀杀杀杀杀杀杀杀杀</p><hr><h4 id="5-尝试不同的分类算法"><a href="#5-尝试不同的分类算法" class="headerlink" title="5. 尝试不同的分类算法"></a>5. 尝试不同的分类算法</h4><p>水水水水水水水水水水</p><hr><h4 id="6-对模型进行惩罚"><a href="#6-对模型进行惩罚" class="headerlink" title="6. 对模型进行惩罚"></a>6. 对模型进行惩罚</h4><p>杀杀杀杀杀杀杀杀杀</p><hr><h4 id="7-从新的角度看问题"><a href="#7-从新的角度看问题" class="headerlink" title="7. 从新的角度看问题"></a>7. 从新的角度看问题</h4><p>水水水水水水</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;针对类不平衡数据数据的处理方法&quot;&gt;&lt;a href=&quot;#针对类不平衡数据数据的处理方法&quot; class=&quot;headerlink&quot; title=&quot;针对类不平衡数据数据的处理方法&quot;&gt;&lt;/a&gt;针对类不平衡数据数据的处理方法&lt;/h3&gt;&lt;p&gt;类不平衡问题（class-imbal</summary>
      
    
    
    
    <category term="论文研读" scheme="https://zlwnge.top/categories/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB/"/>
    
    
    <category term="unbalance data" scheme="https://zlwnge.top/tags/unbalance-data/"/>
    
  </entry>
  
  <entry>
    <title>基于粒子群算法的高维混合特征选择算法</title>
    <link href="https://zlwnge.top/2021/08/08/%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%BE%A4%E7%AE%97%E6%B3%95%E7%9A%84%E9%AB%98%E7%BB%B4%E6%B7%B7%E5%90%88%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95/"/>
    <id>https://zlwnge.top/2021/08/08/%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%BE%A4%E7%AE%97%E6%B3%95%E7%9A%84%E9%AB%98%E7%BB%B4%E6%B7%B7%E5%90%88%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95/</id>
    <published>2021-08-07T16:00:00.000Z</published>
    <updated>2021-08-08T04:58:36.904Z</updated>
    
    <content type="html"><![CDATA[<h3 id="A-PSO-Based-Hybrid-Feature-Selection-Algorithm-for-High-Dimensional-Classification"><a href="#A-PSO-Based-Hybrid-Feature-Selection-Algorithm-for-High-Dimensional-Classification" class="headerlink" title="A PSO Based Hybrid Feature Selection Algorithm for High-Dimensional  Classification"></a>A PSO Based Hybrid Feature Selection Algorithm for High-Dimensional  Classification</h3><p>本文基于过滤器法、包装器法提出了一种在单个进化过程种结合过滤器和包装器的新方法。</p><p>创新点：</p><ul><li>结合过滤器法和包装器法提出一种混合特征选择方法</li><li>提出了一种新的利用对称不确定性的局部搜索启发式方法改进算法的解</li></ul><!--Read more--><h4 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h4><p>​        针对局部搜索的随机翻转机制，提出一种新的局部搜索启发式算法，该算法在选择翻转特征时使用了一种过滤措施，从而更有可能找到好的解。</p><p>​        在基于包装器的粒子群优化算法中，使用过滤局部搜索去除gbest中的冗余特征，使用互信息评估特征相关性和冗余度。</p><p>​        首先使用统计聚类技术将所有特征聚类成N个聚类，在局部搜索中，若其聚类中选择了超过预定义数量的特征则删除gbest中对应的特征。</p><hr><h3 id="2-提出的算法"><a href="#2-提出的算法" class="headerlink" title="2. 提出的算法"></a>2. 提出的算法</h3><p><img src="http://image.zlwnge.top/20210808125752.png" alt="启发式局部搜索"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;A-PSO-Based-Hybrid-Feature-Selection-Algorithm-for-High-Dimensional-Classification&quot;&gt;&lt;a href=&quot;#A-PSO-Based-Hybrid-Feature-Selection-A</summary>
      
    
    
    
    <category term="论文研读" scheme="https://zlwnge.top/categories/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB/"/>
    
    
    <category term="Feature Selection" scheme="https://zlwnge.top/tags/Feature-Selection/"/>
    
    <category term="PSO" scheme="https://zlwnge.top/tags/PSO/"/>
    
  </entry>
  
  <entry>
    <title>用于高维特征选择的可变长度的粒子群算法</title>
    <link href="https://zlwnge.top/2021/08/04/%E7%94%A8%E4%BA%8E%E9%AB%98%E7%BB%B4%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E7%9A%84%E9%95%BF%E5%BA%A6%E5%8F%AF%E5%8F%98%E7%9A%84%E7%B2%92%E5%AD%90%E7%BE%A4%E7%AE%97%E6%B3%95/"/>
    <id>https://zlwnge.top/2021/08/04/%E7%94%A8%E4%BA%8E%E9%AB%98%E7%BB%B4%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E7%9A%84%E9%95%BF%E5%BA%A6%E5%8F%AF%E5%8F%98%E7%9A%84%E7%B2%92%E5%AD%90%E7%BE%A4%E7%AE%97%E6%B3%95/</id>
    <published>2021-08-03T16:00:00.000Z</published>
    <updated>2021-08-08T03:49:30.160Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Variable-Length-Particle-Swarm-Optimisation-for-Feature-Selection-on-High-Dimensional-Classification"><a href="#Variable-Length-Particle-Swarm-Optimisation-for-Feature-Selection-on-High-Dimensional-Classification" class="headerlink" title="Variable-Length Particle Swarm Optimisation for Feature Selection on High-Dimensional Classification"></a>Variable-Length Particle Swarm Optimisation for Feature Selection on High-Dimensional Classification</h3><p>本文基于高维特征选择问题提出了一种粒子长度可变的粒子群算法。</p><p>创新点：</p><ul><li><p>粒子长度可变，使得搜索空间更小</p></li><li><p>按相关性降序排列特征，提升其分类特征</p></li><li><p>提出长度改变机制，使算法跳出局部最优，进一步缩小搜索空间</p></li></ul><span id="more"></span><h4 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h4><p>​        主要特征选择方法有：<u>包装器法</u>、<u>过滤器法</u>。包装器法使用分类算法评估特征子集的优良性，而过滤器法基于训练数据的内在特征进行评估。因此包装器法分类性能通常比过滤器法更好，但计算时间更长。</p><p>​        <u>特征排序</u>或特征加权法，是将特征按照其与目标概念间的相关度进行排序，选择预定义数量的最优特征来形成特征子集。但是特征之间可能存在双向、三向或多向的复杂交互作用。当某个特征与其它特征组合时，单独弱相关的特征可能变得非常有用，反之亦然。另外，排名靠前的特征也可能是冗余的，这可能会降低分类算法的性能。所以，独立评估特征并不能很好处理<u>特征交互</u>问题。</p><p>​        与特征排序法相比，<u>特征子集选择法</u>可以一次性评估整个特征子集，可以更好处理特征交互。比较典型的特征子集选择方法有：顺序向前选择（SFS）和顺序向后选择（SBS）。但这些方法应用在高维数据中虽然有效，但计算量太大，即使使用贪婪搜索，也会容易陷入局部最优。而粒子群算法是表现较好的一种全局搜索算法。</p><p>​        所以本文提出一种改进的粒子群算法的特征选择方法——VLPSO。</p><hr><h4 id="2-VLPSO"><a href="#2-VLPSO" class="headerlink" title="2. VLPSO"></a>2. VLPSO</h4><p>​    1. 为了使不同粒子可以具有不同长度，本文提出了一种新的初始化方法，即<u><strong>种群划分</strong></u>（population division）。</p><p>​    2. 在应用粒子群算法之前，<u><strong>基于特征排序方法对特征降序排序</strong></u>。使较为重要的特征总是可以被任何粒子选择；另一方面，较长的粒子可以包含不太相关的特征，使得粒子群算法能够检测可能发生的特征交互，从而产生质量更高的特征子集。</p><ol start="3"><li><p><u><strong>采用CLPSO的更新机制并予以调整</strong></u>，使变长粒子间互相传递信息，增加种群多样性。</p><ul><li>调整CLPSO中的<u><strong>示例分配</strong></u>（exemplar assignment）</li><li>用<u><strong>自适应学习概率</strong></u>（adaptive learning probability）代替CLPSO中的样本选择概率</li></ul></li><li><p>提出<u><strong>长度改变机制</strong></u>（length changing）以缓解早熟收敛。</p></li><li><p>结合<u><strong>局部搜索</strong></u>（local search）以加强VLPSO的局部寻优能力。</p></li><li><p>结合包装器法和过滤器法的优势，使用<u><strong>KNN和距离度量混合的特征评估方法</strong></u>。</p></li></ol><blockquote><p>问题：</p><ul><li>所提算法选择的特征子集是否比原始特征集小，以及与初始版本算法和其他改进版本算法相比子集是否达到相似或更好</li><li>所结合策略是否有助于提出的方法实现更好的分类精度</li><li>所提方法是否显著减少了算法在数据集上的运行时间</li><li>所提算法是否优于传统的特征选择方法</li><li>所提出的策略是否有效、高效地帮助初始版算法提高其在数据集上的性能</li></ul></blockquote><h5 id="2-1-编码"><a href="#2-1-编码" class="headerlink" title="2.1. 编码"></a>2.1. 编码</h5><p>​        如图，VLPSO中每个粒子由三个向量（位置、速度、示例），以及两个变量（学习概率、样本更新次数）表示。</p><p><img src="http://image.zlwnge.top/20210804161557.png"></p><h5 id="2-2-示例分配"><a href="#2-2-示例分配" class="headerlink" title="2.2. 示例分配"></a>2.2. 示例分配</h5><p>​        如图，在CLPSO中，任何粒子都可以作为粒子某一维度的示例。但是VLPSO粒子长度不同，所以其示例长度必须大于等于其本身长度。其中for循环之中的if-else语句用于判断，若随机数大于该粒子的学习概率，则令其本身作为示例；否则随机选择不相同的p1、p2样本，选择较好的作为示例。</p><p><img src="http://image.zlwnge.top/20210806081402.png" alt="image-20210806081402374"></p><h5 id="2-3-自适应学习概率"><a href="#2-3-自适应学习概率" class="headerlink" title="2.3. 自适应学习概率"></a>2.3. 自适应学习概率</h5><p>​        在CLPSO中，粒子学习概率如下式（3）所示，从中可以看出，粒子index越小，其示例越趋向于自身，这种方式显然是不科学的。应该按照粒子的适应度计算学习概率，粒子适应度越高其越应该获得更小的学习概率，而且适应度越坏，越应该向其它粒子学习，所以本文采用式（5）的自适应学习概率。</p><p><img src="http://image.zlwnge.top/20210806083023.png" alt="image-20210806083023753"></p><p><img src="http://image.zlwnge.top/20210806083042.png" alt="image-20210806083042255"></p><p>​        其中<code>S</code>表示种群数量，<code>rank(i)</code>是粒子<code>i</code>的排名，最好的粒子排名第一。</p><h5 id="2-4-种群划分"><a href="#2-4-种群划分" class="headerlink" title="2.4. 种群划分"></a>2.4. 种群划分</h5><p>​        本文提出的变长概念并不是将每个粒子都设置成不同长度，而是将整个种群划分为预定义数量的分区。通过这种方式将搜索空间划分为更小的子空间，从而提高算法性能。</p><p>​        每个分区的粒子数是基于种群大小和分区数计算的，同一分区的粒子具有相同的长度。而每一分区中的粒子长度是根据式（7）计算的，其中最大长度是问题维度。在同一分区中，具有相同长度的粒子可以表示具有不同的特征子集大小的特征子集，如，长度为8的两个粒子，10100001和10001111，分别表示从给定数据集的前8个特征中选择了哪些特征。它们分别对应特征子集大小为3和5的两个特征子集{F1, F3, F8}和{F1, F5, F6, F7, F8}。</p><p><img src="http://image.zlwnge.top/20210806085315.png" alt="image-20210806085315067"></p><p><img src="http://image.zlwnge.top/20210806085332.png" alt="image-20210806085331984"></p><p><img src="http://image.zlwnge.top/20210806085358.png" alt="image-20210806085358838"></p><h5 id="2-5-特征排名"><a href="#2-5-特征排名" class="headerlink" title="2.5. 特征排名"></a>2.5. 特征排名</h5><p>​        本文采用对称不确定性（symmetric uncertainty, SU）将特征按相关性降序排列。通过下式衡量特征F与类标签C间的相关性，相关性越高越好。</p><p><img src="http://image.zlwnge.top/20210806085829.png" alt="image-20210806085829094"></p><p>​        其中H(F)是F的熵，H(F|C)是给定C的F的条件熵，SU(F, C)的值在(0, 1)之间，1代表最相关的特征。</p><h5 id="2-6-长度改变"><a href="#2-6-长度改变" class="headerlink" title="2.6. 长度改变"></a>2.6. 长度改变</h5><p>​        为了帮助算法跳出局部最优，本文提出一种长度改变机制，将粒子引导到更好的区域，特别是当<code>gbest</code>在预定义迭代次数内没有变化时，计算每个分区中所有粒子的平均适应度，并调整粒子的长度以将算法搜索扩展到最佳分区。</p><p>​        在这个过程中，保持最佳分区中的粒子不变，将其它分区中的粒子调整到最佳分区。该过程在将粒子本身信息保留的同时，基于最佳分区长度和当前分区长度动态计算被切割或附加的特征。</p><p><img src="http://image.zlwnge.top/20210806093953.png" alt="image-20210806093953406"></p><p>​        如上图，假设第三个分区为最佳分区，它保持不变，3000成为群体的新最大长度。其余分区粒子长度分别更改为600、1200、1800和2400，其余的400、800、2200和2600维将被切割。如Algorithm 2所示，如果分区中粒子的当前长度比新长度短，则附加更多维度并随机初始化（第12-16行）；否则超出的部分将被移除（第18-21行）。</p><p><img src="http://image.zlwnge.top/20210806094213.png" alt="image-20210806094213694"></p><blockquote><p>​        此机制的出发条件为<code>gbest</code>在迭代n次后仍未改善。所以有必要对超参数n和分区数进行灵敏度分析。</p></blockquote><h5 id="2-7-适应度函数"><a href="#2-7-适应度函数" class="headerlink" title="2.7. 适应度函数"></a>2.7. 适应度函数</h5><p>​        本文通过权重γ将K近邻的精度和距离度量结合形成适应度函数。分类精度可以特征子集的性能，距离度量可以近似表示这些特征能在多大的距离范围内区分实例的类别。</p><p><img src="http://image.zlwnge.top/20210806102231.png" alt="image-20210806102231331"></p><p>​        为了处理高维数据集中的不平衡数据，我们对适应度函数的第一个分量使用了基于式（11）计算的平衡精度。对训练数据进行留一交叉验证，评价KNN的性能。</p><p><img src="http://image.zlwnge.top/20210806102435.png" alt="image-20210806102435880"></p><p>​        其中c是问题的总类别，TPRi是类别i的分类正确率。</p><p>​        基于式（12）计算距离度量，旨在最大化不同类实例间的距离（Db），最小化同一类实例间的距离（Dw）。</p><p><img src="http://image.zlwnge.top/20210806102728.png" alt="image-20210806102728344"></p><p>​        其中M是训练集中的实例数，两实例间的距离Dis(I, J)采用曼哈顿度量，为了更好地应用这个距离度量，训练数据被缩放到[0， 1]之间。</p><h5 id="2-8-VLPSO算法"><a href="#2-8-VLPSO算法" class="headerlink" title="2.8. VLPSO算法"></a>2.8. VLPSO算法</h5><p><img src="http://image.zlwnge.top/20210806132453.png" alt="image-20210806132452963"></p><p>​        算法有三个输入参数，分区数、gbest不被改进以更新粒子样本的最大迭代次数α、gbest不被改变以改变粒子长度的最大迭代次数β。</p><p>​        算法先对特征进行重新排列，然后初始化所有分区、计算学习概率并为每个粒子分配示例。第二个循环是进化过程，在这一过程中如果gbest经过β次迭代仍未改善则触发长度改变机制。</p><p>​        算法的时间复杂度主要由粒子群算法更新时间和适应度评估时间组成，而后者占更大比例。但即使是在最坏的情况下（所有粒子选择所有特征），由于较短粒子的长度，所提出的方法仍然只花费一半的时间（与其他算法相比）。</p><h5 id="2-9-VLPSO-LS"><a href="#2-9-VLPSO-LS" class="headerlink" title="2.9. VLPSO-LS"></a>2.9. VLPSO-LS</h5><p>​        本文将局部搜索与VLPSO结合，提出VLPSO-LS。</p><p>​        该局部搜索通过基于式（8）对特征相关性的SU度量，随机移除一些冗余特征并添加更多相关特征。具体表现为：选择当前pbest长度的25%个特征，扫描该部分特征，删除其中冗余的特征，并添加相关特征。</p><blockquote><p>如果该特征与其他已选中的特征间的相关性大于该特征与类标签之间的相关性，则该特征是冗余的；如果该特征与类标签间的相关性大于该特征与随机选取部分中所有已选中的特征间的平均相关性，则该特征是相关的。</p></blockquote><p>​        由于每进行一次局部搜索都要评估一次，这大大增加了计算时间。为了加快算法的速度，这里采用快速适应度评估策略。即从当前距离中分别添加或减去从当前pbest中添加或移除的特征的值差来计算实例间的新距离。因为局部搜索只是对pbest的一小部分进行了操作，所以该策略节省了大量评估时间。</p><blockquote><p>这里也可以预定义局部搜索的频率，在有效性和效率之间折衷。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;Variable-Length-Particle-Swarm-Optimisation-for-Feature-Selection-on-High-Dimensional-Classification&quot;&gt;&lt;a href=&quot;#Variable-Length-Particle-Swarm-Optimisation-for-Feature-Selection-on-High-Dimensional-Classification&quot; class=&quot;headerlink&quot; title=&quot;Variable-Length Particle Swarm Optimisation for Feature Selection on High-Dimensional Classification&quot;&gt;&lt;/a&gt;Variable-Length Particle Swarm Optimisation for Feature Selection on High-Dimensional Classification&lt;/h3&gt;&lt;p&gt;本文基于高维特征选择问题提出了一种粒子长度可变的粒子群算法。&lt;/p&gt;
&lt;p&gt;创新点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;粒子长度可变，使得搜索空间更小&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;按相关性降序排列特征，提升其分类特征&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;提出长度改变机制，使算法跳出局部最优，进一步缩小搜索空间&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="论文研读" scheme="https://zlwnge.top/categories/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB/"/>
    
    
    <category term="Feature Selection" scheme="https://zlwnge.top/tags/Feature-Selection/"/>
    
    <category term="PSO" scheme="https://zlwnge.top/tags/PSO/"/>
    
    <category term="可变长度" scheme="https://zlwnge.top/tags/%E5%8F%AF%E5%8F%98%E9%95%BF%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+github个人博客搭建</title>
    <link href="https://zlwnge.top/2021/08/02/HEXO/"/>
    <id>https://zlwnge.top/2021/08/02/HEXO/</id>
    <published>2021-08-02T13:35:27.075Z</published>
    <updated>2021-08-03T11:20:35.695Z</updated>
    
    <content type="html"><![CDATA[<h3 id="01-HEXO框架的本地安装与运行"><a href="#01-HEXO框架的本地安装与运行" class="headerlink" title="01. HEXO框架的本地安装与运行"></a>01. HEXO框架的本地安装与运行</h3><ul><li>安装<a href="https://git-scm.com/download/win">git</a></li><li>安装<a href="https://nodejs.org/en/download/">node.js</a></li><li>git配置用户名和邮箱，其中<code>username</code>是github用户名，<code>useremail</code>是github绑定的邮箱</li></ul><blockquote><p><code>git config --global user.name &quot;username&quot;</code></p><p> <code>git config --global user.email useremail </code></p></blockquote><p>在命令行中输入</p><ul><li><code>npm install -g hexo-cli</code></li></ul><blockquote><p>出现该警告<img src="http://image.zlwnge.top/20210803182934.png" alt="image-20210802141411601"></p></blockquote><blockquote><p>原因： fsevent是mac osx系统的，在win或者Linux下使用了 所以会有警告，忽略就好了。</p></blockquote><ul><li><code>hexo init blog</code></li><li><code>cd blog</code></li><li><code>npm install</code></li><li><code>hexo server</code></li></ul><blockquote><p><img src="http://image.zlwnge.top/20210803182935.png" alt="image-20210802141835027"></p></blockquote><blockquote><p>表示成功安装，可访问<code>http://localhost:4000</code></p></blockquote><h3 id="02-HEXO文件打包"><a href="#02-HEXO文件打包" class="headerlink" title="02. HEXO文件打包"></a>02. HEXO文件打包</h3><p>生成静态网站<code>hexo g</code></p><p>生成好的 public 文件夹可以直接当成静态网站进行部署</p><h3 id="03-HEXO主题设置"><a href="#03-HEXO主题设置" class="headerlink" title="03. HEXO主题设置"></a>03. HEXO主题设置</h3><p><code>https://hexo.io/themes/</code></p><p>点击主题名进入其github仓库，根据提示完成安装</p><blockquote><p>分5.0以前版本的安装和5.0以后版本的安装。</p></blockquote><p>这里使用的是<code>git clone https://github.com/autoload/hexo-theme-auto.git themes/auto</code>进行安装，安装完毕后，打开<code>_config.yml</code>文件。将<code>_config.yml</code>中的<code>theme</code>字段值改为<code>auto</code>。</p><h3 id="04-自定义博客结构"><a href="#04-自定义博客结构" class="headerlink" title="04. 自定义博客结构"></a>04. 自定义博客结构</h3><p>根据自身需要使用网页开发的基本技术将<code>theme</code>下的模板文件进行修改。</p><h3 id="05-写博客以及文章分类与标签"><a href="#05-写博客以及文章分类与标签" class="headerlink" title="05. 写博客以及文章分类与标签"></a>05. 写博客以及文章分类与标签</h3><p>参见<a href="https://hexo.io/docs/front-matter">hexo docs文件</a></p><p><img src="http://image.zlwnge.top/20210803182936.png" alt="image-20210802204144823"></p><h3 id="06-让代码显示得更加美观"><a href="#06-让代码显示得更加美观" class="headerlink" title="06. 让代码显示得更加美观"></a>06. 让代码显示得更加美观</h3><p>引入<code>&lt;linkrel=&quot;stylesheet&quot; href=&quot;https://oindk07nf.qnssl.com/atom-one-dark.css&quot; media=&quot;screen&quot; type=&quot;text/css&quot;&gt;</code>后，按照<a href="https://hexo.io/docs/tag-plugins#Code-Block">hexo中tag-plugins的code-block</a>书写代码即可。</p><h3 id="07-本地写作时图床的最佳解决方案"><a href="#07-本地写作时图床的最佳解决方案" class="headerlink" title="07. 本地写作时图床的最佳解决方案"></a>07. 本地写作时图床的最佳解决方案</h3><h3 id="08-必备插件"><a href="#08-必备插件" class="headerlink" title="08. 必备插件"></a>08. 必备插件</h3><h3 id="09-将博客部署到github"><a href="#09-将博客部署到github" class="headerlink" title="09.将博客部署到github"></a>09.将博客部署到github</h3><p>如图，新建一个repository，</p><p><img src="http://image.zlwnge.top/20210803183125.png" alt="image-20210803183125694"></p><p>将<code>_config.yml</code>中的<code>url</code>值设置为<code>https://zlwnge.github.io/</code>，将<code>path</code>值设置为<code>index.html</code>，<code>deploy</code>下，<code>type</code>值为<code>git</code>，<code>repository</code>值为<code>https://github.com/zlwnge/zlwnge.github.io.git/</code>，<code>branch</code>值为<code>master</code>。</p><blockquote><p>若没有这些键，可以自行添加。但注意冒号后一定要跟一个空格。</p></blockquote><p>部署：<code>$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code></p><p>访问：在浏览器中输入<code>https://zlwnge.github.io/</code>就可以访问了。</p><p><img src="http://image.zlwnge.top/20210803192024.png" alt="image-20210803192024696"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;01-HEXO框架的本地安装与运行&quot;&gt;&lt;a href=&quot;#01-HEXO框架的本地安装与运行&quot; class=&quot;headerlink&quot; title=&quot;01. HEXO框架的本地安装与运行&quot;&gt;&lt;/a&gt;01. HEXO框架的本地安装与运行&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;安装</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://zlwnge.top/2021/08/02/hello-world/"/>
    <id>https://zlwnge.top/2021/08/02/hello-world/</id>
    <published>2021-08-02T05:58:02.700Z</published>
    <updated>1985-10-26T08:15:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
